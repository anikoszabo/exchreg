---
title: Code to reproduce results in _Semi-parametric generalized linear model for
  binomial data with varying cluster sizes_
author: "Aniko Szabo"
output:
  html_document:
    df_print: paged
---


```{r setup, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE, autodep=TRUE)

library(exchreg)
library(knitr)
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_classic())

library(CorrBin) ## utilities for working with correlated binomial data
library(VGAM) ## for beta-binomial regression
library(geepack)  ## for GEE

set.seed(20210814)
data(boric_acid)
```


# Application to boric acid developmental toxicity data

The boric acid data is included in the package as an example dataset `boric_acid`. We fit a GEE, beta-binomial, and semi-parameteric GLM model with a logit-link.

```{r BA_gee}
boric_acid$Trt <- factor(boric_acid$Trt, levels=c("0","0.1", "0.2","0.4"),
                         labels = c("0%", "0.1%", "0.2%", "0.4%"))
# convert data into one-row per cluster-member format needed for GEE
ba_long <- unwrap(boric_acid)

# run GEE
ba_gee <- geeglm(Resp ~ Trt, data=ba_long, id = ID, family=binomial,
                 corstr = "exch")
ba_gee
```

```{r BA_betabin}
# fit beta-binomial model
ba_bb <- vgam(cbind(NResp, ClusterSize - NResp) ~ Trt, weights = Freq,
                 data=boric_acid, family =  betabinomial(lmu="logitlink"))
summaryvglm(ba_bb)
```

```{r BA_spglm}
ba_spglm <- spglm(cbind(NResp, ClusterSize - NResp) ~ Trt, data=boric_acid,
                  weights  = Freq)

ba_spglm
```

```{r Table1a}
table1 <- list(GEE = cbind(Est = coef(ba_gee), SE=sqrt(diag(vcov(ba_gee)))),
                BB = cbind(Est = coef(ba_bb)[-2],      # second value is logit(rho)   
                           SE=sqrt(diag(vcov(ba_bb)))[-2]),  
                SPGLM = cbind(Est = coef(ba_spglm), SE=sqrt(diag(vcov(ba_spglm)))))
table1
```

```{r Table1, eval=FALSE}
table1 <- data.frame(GEE = cbind(Est = coef(ba_gee), SE=sqrt(diag(vcov(ba_gee)))),
                BB = cbind(Est = coef(ba_bb)[-2],      # second value is logit(rho)   
                           SE=sqrt(diag(vcov(ba_bb)))[-2]),  
                SPGLM = cbind(Est = coef(ba_spglm), SE=sqrt(diag(vcov(ba_spglm)))))
kable(table1, digits=3)
```

Fitted values for the outcome probabilities can be obtained for the SPGLM and Beta-binomial models, as well as using non-parametric estimates within each group.

```{r PredictBB}
newd <- data.frame(Trt=unique(boric_acid$Trt))

# beta-binomial
mns_rho <- predictvglm(ba_bb, type="link", newdata=newd, untransform=TRUE) 

fit_bb <- tibble(newd, as_tibble(mns_rho)) %>%
  group_by(Trt) %>%
  mutate(ClusterSize = 10,
         NResp = list(0:10),
         Prob = list(dbetabinom(0:10, size=10, prob=mu, rho=rho))) %>%
  unnest(cols=c(NResp, Prob)) %>%
  mutate(Model="Beta-binomial")

```

```{r PredictSPGLM}
fit_spglm <- crossing(newd, NResp=0:10) %>%
  mutate(ClusterSize = 10,
         Prob = predict(ba_spglm, newdata=., type="prob", 
                          newn=ClusterSize, newevents = NResp),
         Model = "SPGLM")
```

```{r PredictNonparam}
fit_nonpar <- mc.est(boric_acid) %>%
  filter(ClusterSize == 10) %>%
  mutate(Model="Non-parametric")

```

```{r PredictPlot}
fits <- bind_rows(fit_bb, fit_spglm, fit_nonpar)

ggplot(fits, aes(x=NResp, y=Prob, colour=Model)) +
  facet_wrap(~Trt) +
  geom_point() +
  geom_line() +
  scale_x_continuous("# of affected animals", breaks=seq(0,10,by=2)) +
  ylab("Probability") +
  theme_bw()

```




# Simulation study

Goal:

 * simulate data with four settings:
 
  1. Both the beta-binomial and semi-parameteric model are correct - a binomial backbone, which belongs to the exponential family
  2. Only the beta-binomial model is correct - generated from a beta-binomial distribution
  3. Only the semi-parametric model is correct - generated from the spglm, with a zero-inflated beta-binomial backbone
  4. Neither model is correct - generated from a zero-inflated beta-binomial distribution
 * fit the data using our semi-parametric regression model, beta-binomial regression (potentially misspecified distribution), and GEE (marginal only)
 


## Simulating data

We will have one binary predictor $X_1 \sim Bern(0.5)$ with $beta_1=0.5$ and one continuous predictor $X_2 \sim N(0,1)$ with $\beta_2 = 1$. The cluster size distribution will be binomial.

```{r SimOne}
beta_correct <- c(0, 0.5, 1)
sim_covariates <- function(n, maxClusterSize = 10, aveClusterSize = 7, beta=beta_correct){
  x1 <- rbinom(n, size=1, prob=0.5)
  x2 <- rnorm(n)
  lp <- cbind(1, x1, x2) %*% beta
  mns <- 1/(1+exp(-lp))
  
  cs <- rbinom(n, size=maxClusterSize, prob=aveClusterSize/maxClusterSize)
  
  data.frame(ClusterSize = cs, X1=x1, X2=x2, p_resp = mns)
}

# add random response counts using SPGLM model
add_response_spglm <- function(cov_data, q0){
  # cov_data should come from sim_covariates
  
  simres <- ran.spglm(n=cov_data$ClusterSize, means = cov_data$p_resp, q0 = q0)
  res <- cov_data
  res$NResp <- simres$NResp
  res$Trt <- "All"
  res$Freq <- 1
  class(res) <- c("CBData", class(res))
  res
}

# add random response counts from zero-inflated beta-binomial 
add_response_zoibb <- function(cov_data, pstr0, rho){
  # cov_data should come from sim_covariates
  
  res <- cov_data
  res$NResp <- rzoibetabinom(n = nrow(cov_data),
                             size = cov_data$ClusterSize,
                             prob = cov_data$p_resp,
                             rho = rho,
                             pstr0 = pstr0)
  res$Trt <- "All"
  res$Freq <- 1
  class(res) <- c("CBData", class(res))
  res
}
```

## Analyzing a simulated dataset

```{r AnalyzeOne}
run_analysis <- function(dat){
  #GEE
  dat_long <- unwrap(dat)
  res_gee <- geeglm(Resp ~ X1 + X2, data=dat_long, id = ID, family=binomial,
                 corstr = "exch")
  #Beta-binomial
  res_bb <- vgam(cbind(NResp, ClusterSize - NResp) ~  X1 + X2, weights = Freq,
                 data=dat, family =  betabinomial(lmu="logitlink"))
  #SPGLM
  op <- options(warn=-1)
  res_spglm <- spglm(cbind(NResp, ClusterSize - NResp) ~ X1 + X2, data=dat,
                   weights  = Freq)
  options(op)
  
  nms <- names(coef(res_spglm))
  res <- bind_rows(
    GEE = tibble(Term = nms, 
                 Est=coef(res_gee), 
                 SE = sqrt(diag(vcov(res_gee)))),
    BB = tibble(Term = nms,
                Est = coef(res_bb)[-2],      # second value is logit(rho)   
                SE=sqrt(diag(vcov(res_bb)))[-2]),
    SPGLM = tibble(Term = nms,
                   Est = coef(res_spglm), 
                   SE= sqrt(diag(vcov(res_spglm)))),
    .id = "Model")
  res
}
```


## Run simulations



```{r ActualSim1, warning=FALSE}
R <- 50

# Scenario 1: binomial PDF
sim1 <- 
  replicate(R,
            {simd <- sim_covariates(100) %>% add_response_zoibb(pstr=0, rho=0);
             run_analysis(simd)}, 
            simplify = FALSE)  %>%
   bind_rows(.id="ID")
```

```{r ActualSim2, warning=FALSE}
# Scenario 2: binomial PDF
sim2 <- 
  replicate(R,
            {simd <- sim_covariates(100) %>% add_response_zoibb(pstr=0, rho=0.3);
             run_analysis(simd)}, 
            simplify = FALSE) %>%
   bind_rows(.id="ID")

```

```{r ActualSim3, warning=FALSE}
# Scenario 3: SPGLM with zero-inflated betabinomial backbone
sim3 <- 
  replicate(R,
            {simd <- sim_covariates(100) %>% 
              add_response_spglm(q0 = dzoibetabinom(0:10, size=10, prob=0.4, rho = 0.3, pstr0 = 0.1));
             run_analysis(simd)}, 
            simplify = FALSE)  %>%
   bind_rows(.id="ID")

```

```{r ActualSim4, warning=FALSE}
# Scenario 4: zero-inflated betabinomial 
sim4 <- 
  replicate(R,
            {simd <- sim_covariates(100) %>% add_response_zoibb(pstr=0.1, rho=0.3);
             run_analysis(simd)}, 
            simplify = FALSE)  %>%
   bind_rows(.id="ID")

```



## Compare results

```{r Compare}
comb <- bind_rows(`Both correct` = sim1, 
                  `BB correct`= sim2,
                  `SPGLM correct` = sim3, 
                  `Neither correct` = sim4,
                  .id="Generator") 

# get correct values of parameters on a logit-model scale
correct <- tibble(Term = c("(Intercept)","X1","X2"),
                  Correct = beta_correct)
comb <- left_join(comb, correct, by="Term")

scomb <- comb %>%
  group_by(Generator, Term, Model) %>%
  summarize(bias = mean(Est-Correct, na.rm=TRUE),
            mc.se = sd(Est, na.rm=TRUE),
            se = mean(SE, na.rm=TRUE),
            .groups="drop_last") %>%
  mutate(rel.eff = mc.se / mc.se[Model=="GEE"]) %>%
  ungroup() %>%
  arrange(Generator, Model, Term)
kable(scomb, digits=3)
```

```{r ComparePlot}
ggplot(comb, aes(x=Model, y=Est, colour=Model)) +
  facet_grid(Generator~Term) +
  geom_hline(aes(yintercept=Correct)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha=0.3, height=0)
```

# Session information
```{r Info}
sessionInfo()
```


